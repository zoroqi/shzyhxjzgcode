# 2022-11-29

真的是一步一个坎啊.
本以为会在最后处理输入, 输出和命令行参数卡主,
    但是发现实现 decode 就卡主了.
在处理读取中文字符的时候, 好像要用到 State Monad.
问题是这个再看 rwh 的时候也没有完全理解,
    本以为不会这么快就用到这个知识点,
    但竟然这么快可能要用上, 这就有点累了.

今天遇到的另一个问题和读取文本有关.
不知道如何读取 pipeline, 所以改成了先读取文件的策略.
读取文件最开始用用的是 Data.ByteString 中的 fromFilePath,
    但是这个读不出来, 只是把文件名给输出了,
    之后换了一个 readFile 好了.
之后在看咋搞吧.

最后一个问题是, 我在实现的时候需要把 encode 的返回值变成 `IO String` 吗?
现在我是在 main 里面加了一个 return 来处理的, 不知道这样好不好.

至少今天实现的 encode 逻辑基本是对的, encode 后的内容可以用 golang 的代码进行 decode

# 2022-12-06

尝试通过 stdin 读取输入, 直接使用 getLine 作为尝试,
    可以实现读取, 但只能读取一行.
我可以切换到 getContents , 但是这个是一个严格求值的函数, 我想找一个惰性求值的.

发现 ByteString 包有一个 interact 可以尝试看看, 一个直接的管道函数, 这个就比较简单了.
但这个输出有问题, ByteString 是 Word8 的只能输出 ASCII 部分的内容, 超出部分会乱码.
尝试用别的包里的 interact 来替换看看, 使用 System.IO 里的就好了.

现在问题是, 我可以读写指定文件, 也可以使用 stdin/stdout, 但不能混合使用.
这个不知道咋解决的, golang 我用了一个狗血的方案来实现这个逻辑兼容, 但这里不知道咋做了.
还有就是狗血的文件错误问题了, 那个也不知道咋处理.
